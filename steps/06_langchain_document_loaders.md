### **Krok 6: Integracja LangChain Document Loaders do odczytu plików**\n\nW tym kroku zintegrujemy z naszym agentem `DocumentLoaders` z biblioteki LangChain. Są to wyspecjalizowane komponenty, które potrafią wczytać dane z różnych źródeł (plików, stron internetowych, baz danych) i przekształcić je w ustandaryzowany format `Document`, z którym LangChain potrafi efektywnie pracować.\n\nUżyjemy biblioteki `unstructured`, która jest potężnym narzędziem obsługującym wiele formatów plików (PDF, DOCX, TXT, MD, JSON i inne) pod jednym, spójnym interfejsem. To znacznie uprości kod naszego agenta.\n\n**Co masz zrobić:**\n\n1.  **Zaktualizuj `requirements.txt`:**\n    *   Musimy dodać `unstructured` wraz z zależnościami potrzebnymi do parsowania interesujących nas plików. Dodatkowo `python-magic-bin` jest przydatny w systemie Windows do automatycznego wykrywania typów plików.\n    *   Otwórz plik `requirements.txt` i dodaj/zaktualizuj następujące linie:\n\n    ```txt\n    django\n    langchain\n    langgraph\n    python-dotenv\n    # Usunąć poprzednie wpisy: python-docx, pypdf\n    # Dodać unstructured z dodatkami\n    unstructured[docx,pdf,md,json]\n    python-magic-bin\n    ```\n    *   **Uwaga:** `unstructured` to duża biblioteka. `[docx,pdf,md,json]` instruuje `pip`, aby zainstalować dodatkowe zależności potrzebne do obsługi tych konkretnych formatów.\n\n2.  **Zainstaluj nowe zależności:**\n    *   W terminalu z aktywnym środowiskiem wirtualnym, uruchom ponownie instalację z pliku `requirements.txt`:\n        ```bash\n        pip install -r requirements.txt\n        ```\n    *   Instalacja może chwilę potrwać. Jeśli napotkasz błędy, mogą one być związane z brakiem zależności systemowych (np. `poppler` dla PDF-ów z obrazkami). Na tym etapie podstawowa instalacja powinna wystarczyć dla dokumentów tekstowych.\n\n3.  **Zaktualizuj `ingestion/agents.py`:**\n    *   Teraz zastąpimy naszą prowizoryczną metodę `_read_document_content` logiką wykorzystującą `UnstructuredFileLoader` z LangChain.\n    *   Otwórz plik `ingestion/agents.py` i zmodyfikuj go, aby wyglądał następująco:\n\n    ```python\n    # ingestion/agents.py\n    import os\n    from django.conf import settings\n    from ingestion.models import Document\n    # Nowe importy z LangChain\n    from langchain_community.document_loaders import UnstructuredFileLoader\n\n    class DocumentProcessingAgent:\n        def __init__(self):\n            # Na razie pusto\n            pass\n\n        def process_document(self, document_id: int):\n            \"\"\"\n            Główna metoda do przetwarzania dokumentu.\n            \"\"\"\
            try:\n                document = Document.objects.get(id=document_id)\n                print(f\"Rozpoczynanie przetwarzania dokumentu: {document.file.name}\")\n\n                # Używamy nowej metody opartej na LangChain\n                extracted_text = self._read_document_with_langchain(document.file.path)\n\n                if extracted_text is not None:\n                    document.extracted_text = extracted_text\n                    document.processing_status = \'processed\'\n                    document.save()\n                    print(f\"Dokument {document.file.name} przetworzony pomyślnie. Wyodrębniono {len(extracted_text)} znaków.\")\n                else:\n                    # Jeśli loader zwrócił None, oznacz jako błąd\n                    raise ValueError(\"UnstructuredFileLoader nie zwrócił żadnej treści.\")\n\n                return extracted_text\n\n            except Document.DoesNotExist:\n                print(f\"Dokument o ID {document_id} nie został znaleziony.\")\n                return None\n            except Exception as e:\n                print(f\"Błąd podczas przetwarzania dokumentu {document_id}: {e}\")\n                # Używamy .get() aby uniknąć kolejnego błędu, jeśli dokument nie istnieje\n                doc_to_fail = Document.objects.filter(id=document_id).first()\n                if doc_to_fail:\n                    doc_to_fail.processing_status = \'failed\'\n                    doc_to_fail.save()\n                return None\n\n        def _read_document_with_langchain(self, file_path: str) -> str | None:\n            \"\"\"\n            Wczytuje zawartość pliku przy użyciu UnstructuredFileLoader.\n            Zwraca połączoną treść wszystkich stron/części dokumentu.\n            \"\"\"\
            print(f\"Wczytywanie pliku za pomocą UnstructuredFileLoader: {file_path}\")\n            try:\n                loader = UnstructuredFileLoader(file_path)\n                loaded_documents = loader.load()\n\n                if not loaded_documents:\n                    print(\"Ostrzeżenie: Loader nie zwrócił żadnych dokumentów.\")\n                    return None\n\n                full_content = \"\\n\\n\".join([doc.page_content for doc in loaded_documents])\n                return full_content\n\n            except Exception as e:\n                print(f\"Błąd w UnstructuredFileLoader dla pliku {os.path.basename(file_path)}: {e}\")\n                return None\n\n    ```\n    *   **Usunęliśmy** starą metodę `_read_document_content` i zastąpiliśmy ją `_read_document_with_langchain`.\n    *   **Zaktualizowaliśmy** `process_document`, aby obsługiwała potencjalne błędy z loadera i zapisywała wynik.\n